# YOLOv8n + BiFPN
# 使用加权特征融合替代传统Concat

nc: 4  # 类别数
scales:
  n: [0.33, 0.25, 1024]

# Backbone（保持原始YOLOv8n不变）
backbone:
  - [-1, 1, Conv, [64, 3, 2]]      # 0-P1/2
  - [-1, 1, Conv, [128, 3, 2]]     # 1-P2/4
  - [-1, 3, C2f, [128, True]]      # 2
  - [-1, 1, Conv, [256, 3, 2]]     # 3-P3/8
  - [-1, 6, C2f, [256, True]]      # 4 → 64ch (P3)
  - [-1, 1, Conv, [512, 3, 2]]     # 5-P4/16
  - [-1, 6, C2f, [512, True]]      # 6 → 128ch (P4)
  - [-1, 1, Conv, [1024, 3, 2]]    # 7-P5/32
  - [-1, 3, C2f, [1024, True]]     # 8 → 256ch (P5)
  - [-1, 1, SPPF, [1024, 5]]       # 9

# Head（使用BiFPN加权融合）
head:
  # 自顶向下路径
  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]  # 10 P5->P4
  - [[-1, 6], 1, BiFPNLayer, [128]]  # 11 融合P4特征，输出128ch
  - [-1, 3, C2f, [512]]              # 12 P4输出 (128ch)

  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]  # 13 P4->P3
  - [[-1, 4], 1, BiFPNLayer, [64]]   # 14 融合P3特征，输出64ch
  - [-1, 3, C2f, [256]]              # 15 P3输出 (64ch)

  # 自底向上路径
  - [-1, 1, Conv, [256, 3, 2]]       # 16 P3->P4
  - [[-1, 12], 1, BiFPNLayer, [128]] # 17 融合P4特征
  - [-1, 3, C2f, [512]]              # 18 P4输出 (128ch)

  - [-1, 1, Conv, [512, 3, 2]]       # 19 P4->P5
  - [[-1, 9], 1, BiFPNLayer, [256]]  # 20 融合P5特征
  - [-1, 3, C2f, [1024]]             # 21 P5输出 (256ch)

  # 检测头
  - [[15, 18, 21], 1, Detect, [nc]]  # 22 Detect(P3, P4, P5)